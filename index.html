<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <title>Vintage Restoration Image Watermarker</title>
    </head>
    <!--
        I didn't use AI when making this, that's why it works at least some of
        the time. It was absolutely useless trying to get help with getting this
        shit working, I was so pissed lmao. Two hours wasted.
    -->
    <body>
        <h1>Vintage Restoration Image Watermarker</h1>
        <p>How to use:</p>
        <ol>
            <li>
                Tap the button beneath <strong>Select Images</strong> heading
                and select all of the images you would like to add the watermark
                onto.
            </li>
            <li>
                The images currently being processed will be shown beneath the
                <strong>Working On...</strong> heading. Once there are no image
                names shown there, the process is complete.
                <ul>
                    <li>
                        Note: There may be a delay between when the image
                        disappears from the <strong>Working On...</strong> list
                        and when the image shows up in the
                        <strong>Finished Images</strong> section.
                    </li>
                </ul>
            </li>
            <li>
                To save the watermarked images, tap and hold each image under
                the <strong>Finished Images</strong> heading until the context
                menu opens, then select save to photos.
            </li>
        </ol>
        <h3><label for="images-input">Select Images</label></h3>
        <input
            type="file"
            accept="image/*"
            multiple
            name="images-input"
            id="images-input"
        />
        <h3>Working On...</h3>
        <ol id="input-image-list"></ol>
        <h3>Finished Images</h3>
        <div id="images-output"></div>

        <script type="module">
            const WATERMARK_WIDTH_RATIO = 1100.0 / 1920.0;

            // Load ImageMagick
            import {
                CompositeOperator,
                Gravity,
                initializeImageMagick,
                ImageMagick,
                Magick,
                MagickFormat,
                Point,
            } from "./assets/js/magick.js";
            console.log("Loading ImageMagick wasm...");
            await initializeImageMagick(
                new URL("assets/js/magick.wasm", window.location),
            );
            console.log("ImageMagick ready!");
            await Magick.ready;
            console.log("ImageMagick readier!!");

            // Get DOM elements
            const imagesInput = document.getElementById("images-input");
            const imagesInputList = document.getElementById("input-image-list");
            const imagesOutput = document.getElementById("images-output");
            if (!imagesInput || !imagesInputList || !imagesOutput) {
                alert(
                    "Failed to locate input/input file list/output div???? BROKE BROKE BROKE",
                );
            }

            // I think the input event works file here; haven't had any issues
            // yet.
            imagesInput.addEventListener("input", onAddImages);

            // Listener
            async function onAddImages() {
                const fileList = imagesInput.files;
                if (!fileList.length) {
                    console.log("Ghost update");
                    return;
                }

                imagesInput.style.display = "none";

                // Load the watermark image first
                console.log("Loading watermark.png");
                const watermarkBytes = await getWatermarkImageBytes(
                    "assets/img/watermark.png",
                );

                console.log("Loading images...");
                const files = Array.from(fileList);
                imagesInput.value = "";
                for (const file of files) {
                    const fileLiElem = document.createElement("li");
                    fileLiElem.textContent = file.name;
                    fileLiElem.dataset.referencedFile = file.name;
                    imagesInputList.append(fileLiElem);
                }

                const handleImage = async () => {
                    const file = files.shift();
                    if (file) {
                        const fileLiElem = document.querySelector(
                            `[data-referenced-file="${CSS.escape(file.name)}"]`,
                        );
                        if (!fileLiElem) {
                            console.warn(
                                `Didn't locate fileLiElem for ${file.name}!`,
                            );
                        } else {
                            fileLiElem.style.fontWeight = "bold";
                        }

                        console.log(`Handling image ${file.name}`);
                        await handleImageFile(file, watermarkBytes, fileLiElem);

                        setTimeout(handleImage, 1);
                    } else {
                        imagesInput.style.display = "";
                    }
                };
                setTimeout(handleImage, 1);
            }

            async function getWatermarkImageBytes(imagePath) {
                const response = await fetch(imagePath);
                if (!response.ok) {
                    alert("Failed to access watermark.png!");
                }
                const arrayBuffer = await response.arrayBuffer();
                return new Uint8Array(arrayBuffer);
            }

            async function handleImageFile(file, watermarkBytes, fileLiElem) {
                // Load watermark
                ImageMagick.read(watermarkBytes, async (watermarkImg) => {
                    // Read input file into a byte array
                    console.log(`Reading ${file.name}`);
                    const fileArrayBuffer = await file.arrayBuffer();
                    if (!fileArrayBuffer) {
                        alert(
                            `Failed to get ArrayBuffer for file ${file.name}! RUH ROH SCOOBY`,
                        );
                        return;
                    }
                    const imgBytes = new Uint8Array(fileArrayBuffer);

                    // Load image into ImageMagick
                    console.log(`Reading ${file.name} into ImageMagick`);
                    ImageMagick.read(imgBytes, (img) => {
                        // Clone the watermark to allow scaling to potentially different sizes.
                        console.log("Scaling watermark");
                        // Resize watermark clone
                        const watermarkScale =
                            (img.width * WATERMARK_WIDTH_RATIO) /
                            watermarkImg.width;
                        watermarkImg.resize(
                            watermarkImg.width * watermarkScale,
                            watermarkImg.height * watermarkScale,
                        );

                        console.log("Compositing");
                        // #L1031
                        img.compositeGravity(
                            watermarkImg,
                            Gravity.Center,
                            CompositeOperator.Dissolve,
                            new Point(0, 100),
                            "40",
                        );

                        // Retrieve composited image bytes from ImageMagick and
                        // put the received byte array into a Blob.
                        console.log("Writing output");
                        const imgBlob = img.write(
                            MagickFormat.Png,
                            (imgBytes) => {
                                console.log("Copying output to blob");
                                return new Blob([imgBytes], {
                                    type: "image/png",
                                });
                            },
                        );

                        // Create an image element referencing the Blob
                        // containing the image data.
                        if (!imgBlob) {
                            alert("Failed to create image Blob!! FUCKCK");
                        } else {
                            console.log("Appending output");
                            const imgSrcUrl = URL.createObjectURL(imgBlob);
                            const imgTag = document.createElement("img");
                            imgTag.src = imgSrcUrl;
                            imgTag.style.width = "45vw";
                            imagesOutput.append(imgTag);
                            imagesOutput.append(document.createElement("br"));
                        }

                        // I don't know if these automatically get disposed at
                        // the end of this callback. I noticed I was *not* able
                        // to return the Magick image handle from this callback
                        // as it would lead to an error about accessing an
                        // already-disposed object. I'm going to be safer than
                        // sorrier, we may load a lot of images one after the
                        // other, so I want to make sure I don't pollute memory
                        // enough to freeze the page.
                        console.log(`Cleanup image ${file.name}`);
                        img.dispose();

                        if (fileLiElem) {
                            fileLiElem.remove();
                        }
                    });

                    console.log("Cleanup watermark");
                    watermarkImg.dispose();
                });
            }
        </script>
    </body>
</html>
